use crate::server::buffer::Buffer;
use crate::thread_pool;
use std::collections::HashMap;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

// there can be two types of request, a static one, and a dynamic one
// static one will be a responce stored in a file whose address is stored in `Addr`
// a function will generate responce for dynamic responce which is generated by `Fn`
#[derive(Clone, Debug)]
pub enum Content {
    Fn(fn(Buffer) -> String),
    Addr(String),
}
#[derive(Clone, Debug)]
pub struct Server {
    pub req_hash: HashMap<String, Content>,
    pub port: String,
}
impl Server {
    pub fn new() -> Server {
        Server {
            req_hash: HashMap::new(),
            port: "8080".to_string(),
        }
    }
    pub fn get(&mut self, path: &str, serve: Content) {
        // divides the dynamic responce with the static one
        match serve {
            Content::Fn(f) => {
                self.req_hash
                    .insert(format!("GET {} HTTP/1.1\r\n", path), Content::Fn(f));
            }
            Content::Addr(serve) => {
                self.req_hash.insert(
                    format!("GET {} HTTP/1.1\r\n", path),
                    Content::Addr(serve.to_string()),
                );
            }
        }
    }

    pub fn check_req(&mut self, buffer: [u8; 1024]) -> (String, String) {
        let buffer = Buffer::parse_stream(buffer.clone());
        for req in self.req_hash.keys() {
            if req.starts_with(&buffer.req) {
                return (
                    "HTTP/1.1 200 OK".to_string(),
                    match self.req_hash.clone().get(&req.clone()) {
                        Some(content) => match &content {
                            // generates the content for the request
                            Content::Fn(f) => f(buffer.clone()),
                            Content::Addr(s) => fs::read_to_string(s).unwrap(),
                        },
                        None => {
                            // handle error
                            panic!("error while handleing {}", req);
                        }
                    },
                );
            }
        }
        (
            "HTTP/1.1 404 NOT FOUND".to_string(),
            "public/404.html".to_string(),
        )
    }

    fn handle_connection(&mut self, mut stream: TcpStream) {
        let mut buffer = [0; 1024];
        stream.read(&mut buffer).unwrap();
        let (status_line, content) = self.check_req(buffer.clone());

        let responce = format!(
            "{}\r\nContent-Lenght: {}\r\n\r\n{}",
            status_line,
            content.len(),
            content
        );
        stream.write(responce.as_bytes()).unwrap();
        stream.flush().unwrap();
    }
    pub fn bind(&mut self, port: &str) {
        self.port = port.to_string();
    }
    pub fn start(&self) {
        let listener = TcpListener::bind(String::from("127.0.0.1:") + &self.port).unwrap();
        let pool = thread_pool::ThreadPool::new(4);
        for stream in listener.incoming() {
            let stream = stream.unwrap();
            let mut inst = self.clone();
            pool.execute(move || {
                inst.handle_connection(stream);
            });
        }
        println!("Shutting the server down");
    }
}
